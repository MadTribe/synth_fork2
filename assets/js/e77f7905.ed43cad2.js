"use strict";(self.webpackChunksynth_docs=self.webpackChunksynth_docs||[]).push([[7160],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return m}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var i=a.createContext({}),p=function(e){var t=a.useContext(i),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(i.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,i=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),h=p(n),m=r,d=h["".concat(i,".").concat(m)]||h[m]||u[m]||o;return n?a.createElement(d,s(s({ref:t},c),{},{components:n})):a.createElement(d,s({ref:t},c))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,s=new Array(o);s[0]=h;var l={};for(var i in t)hasOwnProperty.call(t,i)&&(l[i]=t[i]);l.originalType=e,l.mdxType="string"==typeof e?e:r,s[1]=l;for(var p=2;p<o;p++)s[p]=n[p];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},7840:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return l},contentTitle:function(){return i},metadata:function(){return p},assets:function(){return c},toc:function(){return u},default:function(){return m}});var a=n(7462),r=n(3366),o=(n(7294),n(3905)),s=["components"],l={title:"50 ways to crash our product",author:"Andre Bogus",author_title:"Chief Rustacean",author_url:"https://github.com/getsynth",author_image_url:"https://avatars.githubusercontent.com/u/4200835?v=4",tags:["synth","testing","story"],description:"Trying to break our own code for fun and profit",image:"https://storage.googleapis.com/getsynth-public/media/crash.svg",hide_table_of_contents:!1},i=void 0,p={permalink:"/blog/2021/09/27/crash",source:"@site/blog/2021-09-27-crash.md",title:"50 ways to crash our product",description:"Trying to break our own code for fun and profit",date:"2021-09-27T00:00:00.000Z",formattedDate:"September 27, 2021",tags:[{label:"synth",permalink:"/blog/tags/synth"},{label:"testing",permalink:"/blog/tags/testing"},{label:"story",permalink:"/blog/tags/story"}],readingTime:9.68,truncated:!1,authors:[{name:"Andre Bogus",title:"Chief Rustacean",url:"https://github.com/getsynth",imageURL:"https://avatars.githubusercontent.com/u/4200835?v=4"}],prevItem:{title:"Building a startup with Rust",permalink:"/blog/2021/10/07/building-a-startup-with-rust"},nextItem:{title:"So you want to mock an API",permalink:"/blog/2021/09/07/mocking-a-production-api"}},c={authorsImageUrls:[void 0]},u=[{value:"Overview",id:"overview",children:[]}],h={toc:u};function m(e){var t=e.components,n=(0,r.Z)(e,s);return(0,o.kt)("wrapper",(0,a.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,(0,o.kt)("img",{parentName:"p",src:"https://storage.googleapis.com/getsynth-public/media/crash.svg",alt:"50 ways to crash our product"})),(0,o.kt)("p",null,"I personally think that the software we build should make more people's lives better than it makes worse. So when users recently started filing bug reports, I read them with mixed feelings. On one hand, it meant that those particular users were actually using ",(0,o.kt)("a",{parentName:"p",href:"https://getsynth.com"},"synth"),", on the other hand, it also meant that we were failing to give them a polished experience. So when it was my turn to write more stuff about what we do here, I set myself a challenge: Find as many ways as I can to break our product."),(0,o.kt)("p",null,"I briefly considered fuzzing, but decided against it. It felt like cheating. Where's the challenge in that? Also, I wanted to be sure that the bugs would be reachable by ordinary (or perhaps at least exceptional) users, and would accept misleading error messages (that a fuzzer couldn't well decide) as bugs. Finally I am convinced I learn more about some code when actively trying to break it, and that's always a plus. So \"let's get cracking!\" I quoth and off I went."),(0,o.kt)("h3",{id:"overview"},"Overview"),(0,o.kt)("p",null,"Before we start, I should perhaps consider giving a short architectural overview on synth. Basically the software has four parts:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"The DSL (which is implemented by a set of types in ",(0,o.kt)("inlineCode",{parentName:"li"},"core/src/schema")," that get deserialized from JSON),"),(0,o.kt)("li",{parentName:"ol"},"a compiler that creates a ",(0,o.kt)("inlineCode",{parentName:"li"},"graph")," (which form a directed acyclic graph of items that can generate values),"),(0,o.kt)("li",{parentName:"ol"},"export (writing to the data sink) and"),(0,o.kt)("li",{parentName:"ol"},"import facilities (for creating a synth namespace from a database schema)")),(0,o.kt)("p",null,"My plan was to look at each of the components and see if I can find inputs to break them in interesting ways. For example, leaving out certain elements or putting incorrect JSON data (that would not trip up the deserialization part, but lead to incorrect compilation later on) might be a fruitful target. Starting from an empty schema:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json",metastring:"synth",synth:!0},'{\n    "type": "array",\n    "length": 1,\n    "content": {\n        "type": "object"\n    }\n}\n')),(0,o.kt)("p",null,"I then called out ",(0,o.kt)("inlineCode",{parentName:"p"},"synth generate")," until finding a problem. First, I attempted to insert confusing command line arguments, but the ",(0,o.kt)("a",{parentName:"p",href:"https://docs.rs/clap"},"clap"),"-based parser handled all of them gracefully. Kudos!"),(0,o.kt)("p",null,"#","1 The first thing I tried is using a negative length:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json",metastring:"synth",synth:!0},'{\n    "type": "array",\n    "length": -1,\n    "content": {\n        "type": "object"\n    }\n}\n')),(0,o.kt)("p",null,"Which was met with ",(0,o.kt)("inlineCode",{parentName:"p"},'BadRequest: could not convert from value \'i64(-1)\': Type { expected: "U32", got: "i64(-1)" }'),". Not exactly a crash, but the error message could be friendlier and have more context. I should note that this is a very unspecialized error variant within the generator framework. It would make sense to validate this before compiling the generator and emit a more user-friendly error."),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},"Bonus"),": If we make the length ",(0,o.kt)("inlineCode",{parentName:"p"},'"optional": true')," (which could happen because of a copy & paste error), depending on the seed, we will get another ",(0,o.kt)("inlineCode",{parentName:"p"},"BadRequest")," error. The evil thing is that this will only happen with about half of the seeds, so you may or may not be lucky here (or may even become unlucky if another version would slightly change the seed handling)."),(0,o.kt)("p",null,"#","2 Changing the ",(0,o.kt)("inlineCode",{parentName:"p"},"length")," field to ",(0,o.kt)("inlineCode",{parentName:"p"},"{}")," makes for another befuddling error:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-console"},"Error: Unable to open the namespace\n\nCaused by:\n    0: at file 2_unitlength/unitlength.json\n    1: Failed to parse collection\n    2: missing field `type` at line 8 column 1\n")),(0,o.kt)("p",null,"The line number is wrong here, the length should be in line six in the ",(0,o.kt)("inlineCode",{parentName:"p"},"content")," object, not in line eight."),(0,o.kt)("p",null,"#","3 It's not that long that we can use literal numbers for number constants here (for example given the ",(0,o.kt)("inlineCode",{parentName:"p"},"length"),"). The old way would use a ",(0,o.kt)("a",{parentName:"p",href:"/docs/content/number"},(0,o.kt)("inlineCode",{parentName:"a"},"number"))," generator. A recent improvement let us generate arbitrary numbers, however this is likely not a good idea for a ",(0,o.kt)("inlineCode",{parentName:"p"},"length")," field:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json",metastring:"synth",synth:!0},'{\n    "type": "array",\n    "length": {\n        "type": "number",\n        "subtype": "u32"\n    },\n    "content": {\n        "type": "object"\n    }\n}\n')),(0,o.kt)("p",null,"This might be done very quickly, but far more likely it will work for a long time, exhausing memory in the process, because this actually generates a whole lot of empty objects (which are internally ",(0,o.kt)("inlineCode",{parentName:"p"},"BTreeMap"),"s, so an empty one comes at 24 bytes) \u2013 up to 4.294.967.295 of them, which would fill 96GB! While this is not an error per se, we should probably at least warn on this mistake. We could also think about streaming the result instead of storing it all in memory before writing it out, at least unless there are references that need to be stored, and this would also allow us to issue output more quickly."),(0,o.kt)("p",null,"#","4 Let's now add a ",(0,o.kt)("inlineCode",{parentName:"p"},"string"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json",metastring:"synth",synth:!0},'{\n    "type": "array",\n    "length": {\n        "type": "number",\n        "subtype": "u32"\n    },\n    "content": {\n        "type": "object",\n        "s": {\n            "type": "string"\n        }\n    }\n}\n')),(0,o.kt)("p",null,"Oops, I forgot to specify which kind of string. But I wouldn't know that from the error:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-console"},"Error: Unable to open the namespace\n\nCaused by:\n    0: at file 4_unknownstring/unknownstring.json\n    1: Failed to parse collection\n    2: invalid value: map, expected map with a single key at line 10 column 1\n")),(0,o.kt)("p",null,"#","5 Ok, let's make that a ",(0,o.kt)("a",{parentName:"p",href:"/docs/content/string#format"},(0,o.kt)("inlineCode",{parentName:"a"},"format"))," then. However, I forgot that the ",(0,o.kt)("inlineCode",{parentName:"p"},"format"),'must contains a map with the keys "format" and "arguments", putting them into the ',(0,o.kt)("inlineCode",{parentName:"p"},"s")," map directly:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json",metastring:"synth",synth:!0},'{\n    "type": "array",\n    "length": {\n        "type": "number",\n        "subtype": "u32"\n    },\n    "content": {\n        "type": "object",\n        "s": {\n            "type": "string",\n            "format": "say my {name}",\n            "arguments": {\n                "name": "name"\n            }\n        }\n    }\n}\n')),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-console"},"Error: Unable to open the namespace\n\nCaused by:\n    0: at file 5_misformat/misformat.json\n    1: Failed to parse collection\n    2: invalid value: map, expected map with a single key at line 14 column 1\n")),(0,o.kt)("p",null,"#","6 Ok, then let's try to use a faker. Unfortunately, I haven't really read the docs, so I'll just try the first thing that comes to mind:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json",metastring:"synth",synth:!0},'{\n    "type": "array",\n    "length": {\n        "type": "number",\n        "subtype": "u32"\n    },\n    "content": {\n        "type": "object",\n        "name": {\n            "type": "string",\n            "faker": "name"\n        }\n    }\n}\n')),(0,o.kt)("p",null,"This gets us:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-console"},'Error: Unable to open the namespace\n\nCaused by:\n    0: at file empty/empty.json\n    1: Failed to parse collection\n    2: invalid type: string "name", expected struct FakerContent at line 11 column 1\n')),(0,o.kt)("p",null,"One could say that the error is not exactly misleading, but not exactly helpful either. As I've tried a number of things already, I'll take it. Once I get the syntax right (",(0,o.kt)("inlineCode",{parentName:"p"},'"faker": { "generator": "name" }'),", the rest of the faker stuff seems to be rock solid."),(0,o.kt)("p",null,"#","7 Trying to mess up with ",(0,o.kt)("inlineCode",{parentName:"p"},"date_time"),", I mistakenly specify a date format for a ",(0,o.kt)("inlineCode",{parentName:"p"},"naive_time")," value. "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json",metastring:"synth",synth:!0},'{\n   "type": "array",\n   "length": 1,\n   "content": {\n       "type": "object",\n       "date": {\n       "type": "string",\n           "date_time": {\n          "format": "%Y-%m-%d",\n          "subtype": "naive_time",\n          "begin": "1999-01-01",\n          "end": "2199-31-12"\n        }\n      }\n       }\n   }\n}\n')),(0,o.kt)("p",null,"This gets me the following error which is again misplaced at the end of the input, and not exactly understandable. The same happens if I select a date format of ",(0,o.kt)("inlineCode",{parentName:"p"},'"%H"')," and bounds of ",(0,o.kt)("inlineCode",{parentName:"p"},"0")," to ",(0,o.kt)("inlineCode",{parentName:"p"},"23"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-console"},"Error: Unable to open the namespace\n\nCaused by:\n    0: at file 7_datetime/datetime.json\n    1: Failed to parse collection\n    2: input is not enough for unique date and time at line 16 column 1\n")),(0,o.kt)("p",null,"I believe since the time is not constrained in any way by the input, we should just issue a warning and generate an unconstrained time instead, so the user will at least get ",(0,o.kt)("em",{parentName:"p"},"some")," data. Interestingly, seconds seem to be optional, so ",(0,o.kt)("inlineCode",{parentName:"p"},"%H:%M")," works."),(0,o.kt)("p",null,"#","8 More, if I use ",(0,o.kt)("inlineCode",{parentName:"p"},"naive_date")," instead, but make the minimum ",(0,o.kt)("inlineCode",{parentName:"p"},"0-0-0"),", we get the technically correct but still mis-spanned:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-console"},"Error: Unable to open the namespace\n\nCaused by:\n    0: at file 8_endofdays/endofdays.json\n    1: Failed to parse collection\n    2: input is out of range at line 16 column 1s\n")),(0,o.kt)("p",null,"For the record, the error is on line 11."),(0,o.kt)("p",null,"#","9 Now we let ",(0,o.kt)("inlineCode",{parentName:"p"},"date_time")," have some rest and go on to ",(0,o.kt)("a",{parentName:"p",href:"/docs/content/string#categorical"},(0,o.kt)("inlineCode",{parentName:"a"},"categorical")),". Having just one variant with a weight of ",(0,o.kt)("inlineCode",{parentName:"p"},"0")," will actually trigger an ",(0,o.kt)("inlineCode",{parentName:"p"},"unreachable")," error:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json"},'{\n    "type": "array",\n    "length": 1,\n    "content": {\n        "type": "object",\n        "cat": {\n            "type": "string",\n            "categorical": {\n                "empty": 0\n            }\n        }\n    }\n}\n')),(0,o.kt)("p",null,"Well, the code thinks we should not be able to reach it. Surprise!"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-console"},"thread 'main' panicked at 'internal error: entered unreachable code', /home/andre/projects/synth/core/src/schema/content/categorical.rs:82:9\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n")),(0,o.kt)("p",null,"For the record, this is the first internal error I was able to uncover so far. Given this success with categorical strings, it was natural to look if ",(0,o.kt)("inlineCode",{parentName:"p"},"one_of")," could be similarly broken, but the generator just chose the one variant despite its ",(0,o.kt)("inlineCode",{parentName:"p"},"0.0")," weight."),(0,o.kt)("p",null,"#","10 Unsupported types on import"),(0,o.kt)("p",null,"Databases can sometimes contain strange things, and so far the support is in beta, so it was expected that I would find types for which we currently don't implement import. This includes JSON for mysql and postgres, the mysql spatial datatypes as well as postgres' geometric types, user-defined enumerations, postgres' network address types, postgres arrays (soon only nested ones), etc."),(0,o.kt)("p",null,"The way to reproduce that is to create a table with a field of the type, e.g. here with mysql"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sql"},'CREATE TABLE IF NOT EXISTS json (\n    data JSON\n);\n\nDELETE FROM json;\n\nINSERT INTO json (data) VALUES (\'{ "a": ["b", 42] }\');\n')),(0,o.kt)("p",null,"Now call ",(0,o.kt)("inlineCode",{parentName:"p"},"synth import jsonnamespace --from mysql://<user>:<password>@<host>:<port>/<database>")," to get"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-console"},"Error: We haven't implemented a converter for json\n")),(0,o.kt)("p",null,"Since the error is mostly the same for all types, and was somewhat expected, I won't claim a point for each type here."),(0,o.kt)("p",null,"#","11 Exporting an array of nulls into postgres is not correctly implemented, so"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json",metastring:"synth",synth:!0},'{\n    "type": "array",\n    "length": 5,\n    "content": {\n        "type": "object",\n        "s": {\n            "type": "array",\n            "length": 1,\n            "content": {\n                "type": "null"\n            }\n        }\n    }\n}\n')),(0,o.kt)("p",null,"will give us a ",(0,o.kt)("inlineCode",{parentName:"p"},"wrong data type")," error from postgres. The problem here is that we lose the type information from the generator, and just emit ",(0,o.kt)("inlineCode",{parentName:"p"},"null")," values which do not allow us to construct the right types for encoding into a postgres buffer. The solution would be to re-architect the whole system to reinstate that type information, possibly side-stepping sqlx in the process. Note that this is not equal to ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/getsynth/synth/issues/171"},"issue #171"),", which relates to nested arrays."),(0,o.kt)("p",null,"#","12 going back to ","#","3, I thought about other ways to make the code overconsume resources. But time and memory are only one thing to consume, in fact it's easy enough to consume another: The stack. The following bash script:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},'X=\'{ "type": "null" }\'\n\nfor i in $(seq 0 4096)\ndo\n    X="{ \\"type\\": \\"string\\", \\"format\\": { \\"format\\": \\"{x}\\", \\"arguments\\": { \\"x\\": $X } } }"\ndone\n\necho $X > 12_stack_depth/stack_depth.json\nsynth gen --size 1 12_stack_depth\n')),(0,o.kt)("p",null,"will generate the following error:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-console"},"Error: Unable to open the namespace\n\nCaused by:\n    0: at file 12_stack_depth/stack_depth.json\n    1: Failed to parse collection\n    2: recursion limit exceeded at line 1 column 2929\n")),(0,o.kt)("p",null,"So I give up. I've found 1 way to crash our product with an unintended error, reproduced some known limitations and outlined a number of error messages we can improve on. I fell far short of my original goal, which either means I'm really bad at finding errors, or our code is incredibly reliable. Given the track record of software written in Rust, I'd like to think it's the latter, but I'll leave judgement to you."),(0,o.kt)("p",null,"Anyway, this was a fun exercise and I looked at many more things that turned out to just work well, so that's a good thing\u2122. With all the test automation we have today, it's easy to forget that the manual approach also has its upsides. So feel free and try to break your (or our) code!"))}m.isMDXComponent=!0}}]);