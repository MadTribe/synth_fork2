"use strict";(self.webpackChunksynth_docs=self.webpackChunksynth_docs||[]).push([[4504],{3905:function(e,t,n){n.d(t,{Zo:function(){return d},kt:function(){return u}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var c=a.createContext({}),l=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},d=function(e){var t=l(e.components);return a.createElement(c.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,c=e.parentName,d=i(e,["components","mdxType","originalType","parentName"]),m=l(n),u=r,h=m["".concat(c,".").concat(u)]||m[u]||p[u]||o;return n?a.createElement(h,s(s({ref:t},d),{},{components:n})):a.createElement(h,s({ref:t},d))}));function u(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,s=new Array(o);s[0]=m;var i={};for(var c in t)hasOwnProperty.call(t,c)&&(i[c]=t[c]);i.originalType=e,i.mdxType="string"==typeof e?e:r,s[1]=i;for(var l=2;l<o;l++)s[l]=n[l];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},4548:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return i},contentTitle:function(){return c},metadata:function(){return l},toc:function(){return d},default:function(){return m}});var a=n(7462),r=n(3366),o=(n(7294),n(3905)),s=["components"],i={title:"Core concepts"},c=void 0,l={unversionedId:"docs/getting_started/core-concepts",id:"docs/getting_started/core-concepts",isDocsHomePage:!1,title:"Core concepts",description:"This section covers the core concepts found in Synth.",source:"@site/docs/docs/getting_started/core-concepts.md",sourceDirName:"docs/getting_started",slug:"/docs/getting_started/core-concepts",permalink:"/docs/getting_started/core-concepts",editUrl:"https://github.com/getsynth/synth/edit/master/docs/docs/docs/getting_started/core-concepts.md",tags:[],version:"current",frontMatter:{title:"Core concepts"},sidebar:"docsSidebar",previous:{title:"Hello world",permalink:"/docs/getting_started/hello-world"},next:{title:"Schema",permalink:"/docs/getting_started/schema"}},d=[{value:"Namespaces",id:"namespaces",children:[]},{value:"Collections",id:"collections",children:[]},{value:"Field references",id:"field-references",children:[]},{value:"Schema",id:"schema",children:[]},{value:"Importing datasets",id:"importing-datasets",children:[]},{value:"Generating data",id:"generating-data",children:[]}],p={toc:d};function m(e){var t=e.components,n=(0,r.Z)(e,s);return(0,o.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"This section covers the core concepts found in Synth."),(0,o.kt)("h2",{id:"namespaces"},"Namespaces"),(0,o.kt)("p",null,"The ",(0,o.kt)("strong",{parentName:"p"},"namespace")," is the top-level abstraction in Synth. Namespaces are the\nequivalent of traditional ",(0,o.kt)("a",{parentName:"p",href:"https://www.postgresql.org/docs/9.1/ddl-schemas.html"},"schemas")," in the world of relational\ndatabases likes PostgreSQL. ",(0,o.kt)("a",{parentName:"p",href:"#field-references"},"References")," can exist between\nfields in a given namespace, but never across namespaces."),(0,o.kt)("p",null,"Namespaces are simply directories from which ",(0,o.kt)("inlineCode",{parentName:"p"},"synth")," reads a collection of\nschema files. For example, a namespace ",(0,o.kt)("inlineCode",{parentName:"p"},"blog")," could have the following\nstructure:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"\u2514\u2500\u2500 blog/\n    \u251c\u2500\u2500 users.json\n    \u2514\u2500\u2500 posts.json \n")),(0,o.kt)("p",null,"Any file whose extension is ",(0,o.kt)("inlineCode",{parentName:"p"},".json")," in a namespace directory will be opened by\nthe ",(0,o.kt)("a",{parentName:"p",href:"/docs/getting_started/command-line#command-generate"},(0,o.kt)("inlineCode",{parentName:"a"},"synth generate"))," subcommand and considered part of the\nnamespace's schema."),(0,o.kt)("h2",{id:"collections"},"Collections"),(0,o.kt)("p",null,"Every namespace has zero or more ",(0,o.kt)("strong",{parentName:"p"},"collections"),". Collections are addressable by\ntheir name and correspond to ",(0,o.kt)("a",{parentName:"p",href:"https://www.postgresql.org/docs/9.1/sql-createtable.html"},"tables")," in the world of relational\ndatabases. Strictly speaking, collections are a super-set of tables as they are\nin fact arbitrarily deep JSON document trees."),(0,o.kt)("p",null,"Collections are represented in a namespace directory as JSON files. The ",(0,o.kt)("em",{parentName:"p"},"name"),"\nof a collection (the way it is referred to by ",(0,o.kt)("a",{parentName:"p",href:"/docs/getting_started/command-line"},(0,o.kt)("inlineCode",{parentName:"a"},"synth")),") is its filename\nwithout the extension. For example the file ",(0,o.kt)("inlineCode",{parentName:"p"},"bank/transactions.json")," defines a\ncollection named ",(0,o.kt)("inlineCode",{parentName:"p"},"transactions")," in a namespace ",(0,o.kt)("inlineCode",{parentName:"p"},"bank"),"."),(0,o.kt)("p",null,"For a more comprehensive example, let's imagine our namespace ",(0,o.kt)("inlineCode",{parentName:"p"},"bank")," has a\ncollection ",(0,o.kt)("inlineCode",{parentName:"p"},"transactions")," and another collection ",(0,o.kt)("inlineCode",{parentName:"p"},"users"),". The directory\nstructure then looks like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"\u2514\u2500\u2500 bank/\n    \u251c\u2500\u2500 transactions.json\n    \u2514\u2500\u2500 users.json \n")),(0,o.kt)("p",null,"Collections must be valid instances of the ",(0,o.kt)("a",{parentName:"p",href:"/docs/getting_started/schema"},(0,o.kt)("inlineCode",{parentName:"a"},"synth")," schema")," that\ndescribe an array. This means at the top-level all collections must\nbe ",(0,o.kt)("a",{parentName:"p",href:"../content/array"},"array generators"),"."),(0,o.kt)("h2",{id:"field-references"},"Field references"),(0,o.kt)("p",null,"A field reference is a special kind of fields that is useful for declaring\nrelations between different parts of a collection or different collections in\nthe same namespace."),(0,o.kt)("p",null,"A field reference can be specified by using the ",(0,o.kt)("a",{parentName:"p",href:"../content/same-as"},"same_as")," generator\ntype."),(0,o.kt)("p",null,"The value of the ",(0,o.kt)("inlineCode",{parentName:"p"},'"ref"')," field should be the address of the field you want to\nrefer to. A field address takes the\nform ",(0,o.kt)("inlineCode",{parentName:"p"},"<collection name>.<level_0>.<level_1>..."),". For example, say we have a\ncollection ",(0,o.kt)("inlineCode",{parentName:"p"},"users.json")," containing the following schema:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "type": "array",\n  "length": {\n    "type": "number",\n    "subtype": "u64",\n    "range": {\n      "low": 1,\n      "high": 4,\n      "step": 1\n    }\n  },\n  "content": {\n    "type": "object",\n    "username": {\n      "type": "string",\n      "faker": {\n        "generator": "username"\n      }\n    },\n    "credit_card": {\n      "type": "string",\n      "faker": {\n        "generator": "credit_card"\n      }\n    },\n    "id": {\n      "type": "number",\n      "subtype": "u64",\n      "id": {}\n    }\n  }\n}\n')),(0,o.kt)("p",null,"A reference to the ",(0,o.kt)("inlineCode",{parentName:"p"},"username")," field would have the\naddress ",(0,o.kt)("inlineCode",{parentName:"p"},"users.content.username"),". If we want to add a reference to this field\nfrom another collection we would simply add:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json"},'{\n  ...\n  "content": {\n    ...\n    "username": {\n      "type": "same_as",\n      "ref": "users.content.username"\n    },\n    ...\n  }\n}\n')),(0,o.kt)("h2",{id:"schema"},"Schema"),(0,o.kt)("p",null,"The schema is the core data structure that you need to understand to be\nproductive with Synth. The schema represents your data model, it tells Synth\nexactly how to generate data, which fields we need, what types and so on. This\nis a little involved so there is a section devoted to just the ",(0,o.kt)("a",{parentName:"p",href:"/docs/getting_started/schema"},"schema"),"."),(0,o.kt)("h2",{id:"importing-datasets"},"Importing datasets"),(0,o.kt)("p",null,"Synth can ingest and build schemas on the fly with\nthe ",(0,o.kt)("a",{parentName:"p",href:"/docs/getting_started/command-line#command-import"},(0,o.kt)("inlineCode",{parentName:"a"},"synth import"))," command."),(0,o.kt)("h2",{id:"generating-data"},"Generating data"),(0,o.kt)("p",null,"To generate data from an existing namespace use\nthe ",(0,o.kt)("a",{parentName:"p",href:"/docs/getting_started/command-line#command-generate"},(0,o.kt)("inlineCode",{parentName:"a"},"synth generate"))," command."),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"/docs/getting_started/command-line"},(0,o.kt)("inlineCode",{parentName:"a"},"synth"))," uses a seedable pseudo-random source of entropy. By default,\nthe seed is set to a constant value of ",(0,o.kt)("inlineCode",{parentName:"p"},"0")," using the\nRust-native ",(0,o.kt)("a",{parentName:"p",href:"https://docs.rs/rand/0.8.4/rand/trait.SeedableRng.html#method.seed_from_u64"},(0,o.kt)("inlineCode",{parentName:"a"},"rand::SeedableRng::seed_from_u64"))," function. This\nmeans that, by default, the data that ",(0,o.kt)("a",{parentName:"p",href:"/docs/getting_started/command-line"},(0,o.kt)("inlineCode",{parentName:"a"},"synth"))," generates is\ndeterministic: it is only a function of your schema files."),(0,o.kt)("p",null,"This behavior can be tuned (and the seed be changed, or randomized) using\nthe ",(0,o.kt)("inlineCode",{parentName:"p"},"--seed")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"--random")," flag."))}m.isMDXComponent=!0}}]);